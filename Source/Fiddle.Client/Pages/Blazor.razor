@page "/blazor.html"
@inject NavigationManager navigationManager
@inject HttpClient Client
@inject IJSRuntime Runtime
@using System
@using System.Collections.Generic
@using System.IO
@using System.Linq
@using System.Net.Http
@using System.Reflection
@using System.Text
@using System.Threading.Tasks
@using Microsoft.CodeAnalysis
@using Microsoft.CodeAnalysis.CSharp
@using Microsoft.CodeAnalysis.CSharp.Scripting
@using Microsoft.CodeAnalysis.Scripting


@((MarkupString)Svg)
<span style="color: red">@Errors</span>

@code {
    public string Errors { get; set; } = "";
    public string Code { get; set; } = "";
    public string Svg { get; set; } = "";

    protected async override Task OnInitializedAsync()
    {
        // pass the JS a reference to this
        await Runtime.InvokeVoidAsync("initialiseJs", DotNetObjectReference.Create(this));

        // imports are only used by my broken Scripting modifications
        Runny.Compiler.Imports.AddRange(new[] { "System", "System.Linq", "System.Collections.Generic", "OxyPlot", "OxyPlot.Axes", "OxyPlot.Series", "OxyPlot.Annotations" });
        Runny.Compiler.InitializeMetadataReferences(Client);
    }

    [JSInvokable]
    public async void ChangeCode(string newCode)
    {
        Code = newCode;
        CodeChanged();
    }

    async void CodeChanged()
    {
        Runny.Compiler.WhenReady(RunInternal);
    }

    private const int NotWaiting = 0;
    private const int Pending = 1;
    private const int Running = 2;
    private int WaitState = NotWaiting;

    async Task RunInternal()
    {
        int oldState;
        while (System.Threading.Interlocked.CompareExchange(ref WaitState, Pending, oldState = WaitState) != oldState)
        { // spin until we know what it was
        }

        if (oldState == NotWaiting)
        { // start a wait loop
            WaitLoop();
            return;
        }
        else
        { // there is an existing wait loop
            return;
        }
    }

    async void WaitLoop()
    {
    again:
        while (System.Threading.Interlocked.CompareExchange(ref WaitState, Running, Pending) == Pending)
        { // while pending, wait
            await Task.Delay(500);
        }

        await DoUpdate();

        if (System.Threading.Interlocked.CompareExchange(ref WaitState, NotWaiting, Running) == Running)
        { // if nobody has changed from Running to something else, we are done
            StateHasChanged(); // defer update if we are to spin again (does this make sense?)
            return;
        }
        else
        { // else, start again
            goto again;
        }
    }

    async Task DoUpdate()
    {
        var svgExporter = new OxyPlot.SvgExporter() { UseVerticalTextAlignmentWorkaround = true };

        // doesn't work
        //try
        //{
        //    var state = await Runny.Compiler.ExecScriptAsync(Code);
        //    var plot = (OxyPlot.PlotModel)state.GetVariable("plot").Value;
        //    Svg = svgExporter.ExportToString(plot);
        //    return;
        //}
        //catch (Exception ex)
        //{
        //    Errors = ex.Message + "\n" + ex.StackTrace;
        //}

        // works
        var (success, asm) = Runny.Compiler.LoadSource(Code);
        if (success)
        {
            Errors = "";
            try
            {
                var plotModel = (global::OxyPlot.PlotModel)asm.GetType("Program").GetMethod("Plot").Invoke(null, new object[0]);
                Svg = svgExporter.ExportToString(plotModel);
            }
            catch (Exception ex)
            {
                Errors = ex.Message + "\n" + ex.StackTrace;
            }
        }
        else
        {
            Errors = "Compilation error";
        }
    }
}
